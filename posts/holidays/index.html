<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Holidays — Async/Await, Disk IO and PCI Enumeration | CraftyOS Blog</title>
<meta name=keywords content>
<meta name=description content="Multitasking via async/await Multitasking is an important step in making a functional OS. There are 2 models that I could employ, cooperative and preemptive multitasking. Cooperative is easier to implement because tasks voluntarily give up time to allow to scheduler to spawn the next task. Benefits of Cooperative multitasking include a smaller resource footprint because tasks can save what it needs before switching, whilst the preemptive model must save everything as the kernel has no way of knowing what the task will need to keep.">
<meta name=author content="CraftyDH">
<link rel=canonical href=https://craftydh.github.io/CraftyOS-Blog/posts/holidays/>
<link crossorigin=anonymous href=/CraftyOS-Blog/assets/css/stylesheet.min.6cba0d81b5f3f42bb578d49f402ba4175aa72b43def148780b8ad714c957c6f5.css integrity="sha256-bLoNgbXz9Cu1eNSfQCukF1qnK0Pe8Uh4C4rXFMlXxvU=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/CraftyOS-Blog/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://craftydh.github.io/CraftyOS-Blog/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://craftydh.github.io/CraftyOS-Blog/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://craftydh.github.io/CraftyOS-Blog/favicon-32x32.png>
<link rel=apple-touch-icon href=https://craftydh.github.io/CraftyOS-Blog/apple-touch-icon.png>
<link rel=mask-icon href=https://craftydh.github.io/CraftyOS-Blog/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<meta property="og:title" content="Holidays — Async/Await, Disk IO and PCI Enumeration">
<meta property="og:description" content="Multitasking via async/await Multitasking is an important step in making a functional OS. There are 2 models that I could employ, cooperative and preemptive multitasking. Cooperative is easier to implement because tasks voluntarily give up time to allow to scheduler to spawn the next task. Benefits of Cooperative multitasking include a smaller resource footprint because tasks can save what it needs before switching, whilst the preemptive model must save everything as the kernel has no way of knowing what the task will need to keep.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://craftydh.github.io/CraftyOS-Blog/posts/holidays/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-10-03T00:00:00+00:00">
<meta property="article:modified_time" content="2021-10-03T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Holidays — Async/Await, Disk IO and PCI Enumeration">
<meta name=twitter:description content="Multitasking via async/await Multitasking is an important step in making a functional OS. There are 2 models that I could employ, cooperative and preemptive multitasking. Cooperative is easier to implement because tasks voluntarily give up time to allow to scheduler to spawn the next task. Benefits of Cooperative multitasking include a smaller resource footprint because tasks can save what it needs before switching, whilst the preemptive model must save everything as the kernel has no way of knowing what the task will need to keep.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://craftydh.github.io/CraftyOS-Blog/posts/"},{"@type":"ListItem","position":2,"name":"Holidays — Async/Await, Disk IO and PCI Enumeration","item":"https://craftydh.github.io/CraftyOS-Blog/posts/holidays/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Holidays — Async/Await, Disk IO and PCI Enumeration","name":"Holidays — Async\/Await, Disk IO and PCI Enumeration","description":"Multitasking via async/await Multitasking is an important step in making a functional OS. There are 2 models that I could employ, cooperative and preemptive multitasking. Cooperative is easier to implement because tasks voluntarily give up time to allow to scheduler to spawn the next task. Benefits of Cooperative multitasking include a smaller resource footprint because tasks can save what it needs before switching, whilst the preemptive model must save everything as the kernel has no way of knowing what the task will need to keep.","keywords":[],"articleBody":"Multitasking via async/await Multitasking is an important step in making a functional OS. There are 2 models that I could employ, cooperative and preemptive multitasking. Cooperative is easier to implement because tasks voluntarily give up time to allow to scheduler to spawn the next task. Benefits of Cooperative multitasking include a smaller resource footprint because tasks can save what it needs before switching, whilst the preemptive model must save everything as the kernel has no way of knowing what the task will need to keep. However a single task can run for a potentially infinite time by not passing control back to the scheduler. Since the cooperative model is easier to implement I implemented it in the holidays. Next week I will create a preemptive scheduler.\nHow does async/await work? The specific intrinsics are dependent on the language, however for Rust there are 3 things that must be created, an Executor, a Waker and Tasks. When each task is Polled it will try and run to completion if it reaches a bottleneck where it must wait, such as reading from a disk, it yielded it’s time slice etc, it returns Poll::Pending this tells the executor that is must try again later. Alternatively the process returns Poll:Ready(()) , the executor can then remove the task from the task list. But how does the Executor know to try a process again, we could simply add the task to the end of the queue however Rust employs a tactic known as the Waker, when a task must wait it passes a Waker which fundamentally will tell the Executor that the task can do more work. This system works because the waiting will likely be solved by another thread or an interrupt which can then call the Waker and in time the task can continue processing the data.\nBasic Task The example shown in the code snippet spawns a task which then waits for an asynchronous number to be resolved and then prints it out to the screen. This demonstrates how async tasks can wait on their own nested tasks making a tree of async tasks. /// Returns an async number /// Simulates an IO wait by yielding immediatly async fn get_async_number() - u8 { yield_now().await; 32 } /// Gets an async number and prints it to the screen async print_number() { let number = get_async_number().await; println!(\"The number is: {}\", number); } fn main(boot_info: \u0026'static BootInfo) - ! { // Initalization code \t// ... \t// The executor which will run all our tasks \tprintln!(\"Initializing EXECUTOR...\"); let mut executor = Executor::new(); // The spawner is a thread safe spawner \t// It can be passed to tasks so that tasks can spawn new tasks \tlet spawner = executor.get_spawner(); spawner.spawn(Task::new(print_number())); // Start the executor \tprintln!(\"Starting EXECUTOR...\"); executor.run() // The kernel main cannot end so infinite loop \tloop { unsafe { asm!(\"hlt\") } } } Async Keyboard I also implemented a scan code stream for the keyboard which appended keystrokes to an array and then notifies the Executor that the keyboard task can keep doing work. A benefit of this is that as shown in the below code snippet the Keyboard can be a local variable instead of a Global static. Another benefit is all the keyboard handling code is run outside the interrupt loop, allowing interrupts to be processed as quickly as possible.\npub async fn print_keypresses() { let mut scancodes = ScancodeStream::new(); let mut keyboard = Keyboard::new(Us104Key, ScancodeSet1, HandleControl::Ignore); println!(\"Starting keyboard handler...\"); // This loop should never return  while let Some(scancode) = scancodes.next().await { // Process the next scancode  if let Ok(Some(key_event)) = keyboard.add_byte(scancode) { // If there is a new key available  if let Some(key) = keyboard.process_keyevent(key_event) { // Print out the key to the screen  match key { DecodedKey::Unicode(character) = print!(\"{}\", character), DecodedKey::RawKey(key) = print!(\"{:?}\", key), } } } } } Disk IO via ATA How does ATA work? To read/write to an a disk you must first know which ATA bus it is connected to. There are 4 locations ATA 0 Primary/ Secondary and ATA 1 Primary/ Secondary. Then you can ask the device to read or write bytes to the disk, afterwords you can either poll the disk until it says ready (which is what I implemented) or you can ask it send you an interrupt when it is ready. Once the drive is ready you can read/write all 512 bytes from the sector, it is important that all 512 bytes are used otherwise the drive might malfunction.\nDisk enumeration To enumerate each disk I identified each of the 4 ATA drives and then printed it’s disk name if there was a disk connected as shown in the snippet and screenshot below. The ERROR shown in the screenshot is because there was no disk connected to ATA 1.\nfn read_disks() { // ATA 0 lives on IO port 0x1F0 \tlet mut ata_0_master = ATA::new(0x1F0, true); let mut ata_0_slave = ATA::new(0x1F0, false); // ATA 1 lives on IO port 0x170 \tlet mut ata_1_master = ATA::new(0x170, true); let mut ata_1_slave = ATA::new(0x170, true); // Indentify disks \tlet ata_0_master_info = ata_0_master.identify(Vec::with_capacity(512)); let ata_0_slave_info = ata_0_slave.identify(Vec::with_capacity(512)); let ata_1_master_info = ata_1_master.identify(Vec::with_capacity(512)); let ata_1_slave_info = ata_1_slave.identify(Vec::with_capacity(512)); // Print info for each disk \tfor (ata_info, name) in [ (ata_0_master_info, \"ATA 0 Master\"), (ata_0_slave_info, \"ATA 0 Slave\"), (ata_1_master_info, \"ATA 1 Master\"), (ata_1_slave_info, \"ATA 1 Slave\"), ] { // Was there a disk on this bus \tif let Some(info) = ata_info { println!(\"Found drive on {}\", name); println!( \" Serial: {}\\n Model: {}\", str::from_utf8(\u0026info.serial).unwrap_or(\"INVALID SERIAL\"), str::from_utf8(\u0026info.model).unwrap_or(\"INVALID MODEL\"), ); } else { println!(\"No drive found on {}\", name) } } } Interrupts Challenge Initially this code created a DOUBLE_FAULT exception in QEMU but worked in VirtualBox. This made me think that the drive was sending an interrupt which caused the crash as I wasn’t handling it. Eventually I found out that the interrupts were at interrupt number 14 and 15, however I wasn’t able to set them. The reason for this was that they were offsets from the PIC chip which meant that they started at offset 0x20. With this change the interrupt handlers worked and in QEMU I got an interrupt and was able to continue execution.\nPCI Enumeration To enumerate the PCI devices in quite simple, you use for loops. In this code snippet below, we ask each PCI device to tell us its infomation. If none exists on that address a 0 or 0xFFFF is returned. I used wyoos PCI enumeration tutorial as a starting point for this section.\nThis code snipped shows how I went about enurmerating the PCI devices. The screenshot below also shows that it successfully works.\npub fn select_drivers(\u0026mut self) { for bus in 0..8 { for device in 0..32 { for function in 0..8 { // Get device info \tlet mut dev = self.get_device_descriptor(bus, device, function); if dev.vendor_id == 0x0000 || dev.vendor_id == 0xFFFF { // There is no function here :( \tcontinue; } // Enermuerate over each base address that the device has \tfor bar_num in 0..6 { let bar = match self.get_base_address_register(bus, device, function, bar_num) { Some(bar) = bar, None = continue, }; // Ensure there is an address \t// We currently only have support for IO not mmap \tif bar.address != 0 \u0026\u0026 (bar.register_type == BaseAddressRegisterType::InputOutput) { dev.port_base = bar.address.into() } } println!( \"PCI BUS {}, DEVICE {}, FUNCTION {} = VENDOR {:#X}{:X}, DEVICE {:#X}{:02X}\", bus \u0026 0xFF, device \u0026 0xFF, function \u0026 0xFF, (dev.vendor_id \u0026 0xFF00)  8, dev.vendor_id \u0026 0xFF, (dev.device_id \u0026 0xFF00)  8, dev.device_id \u0026 0xFF ); } } } } Timeline update In the holidays I completed many of the tasks from my Timeline. However as stated earlier the USB spec is over 600 pages and as such I will be skipping it. As cooperative multiasking has it’s weeknesses next week I will work on preemtive multitasking instead of moving onto creating a filesystem.\n","wordCount":"1308","inLanguage":"en","datePublished":"2021-10-03T00:00:00Z","dateModified":"2021-10-03T00:00:00Z","author":{"@type":"Person","name":"CraftyDH"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://craftydh.github.io/CraftyOS-Blog/posts/holidays/"},"publisher":{"@type":"Organization","name":"CraftyOS Blog","logo":{"@type":"ImageObject","url":"https://craftydh.github.io/CraftyOS-Blog/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://craftydh.github.io/CraftyOS-Blog/ accesskey=h title="CraftyOS Blog (Alt + H)">CraftyOS Blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://craftydh.github.io/CraftyOS-Blog/archives title=Archive>
<span>Archive</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Holidays — Async/Await, Disk IO and PCI Enumeration
</h1>
<div class=post-meta>October 3, 2021&nbsp;·&nbsp;CraftyDH
</div>
</header>
<div class=post-content><h2 id=multitasking-via-asyncawait>Multitasking via async/await<a hidden class=anchor aria-hidden=true href=#multitasking-via-asyncawait>#</a></h2>
<p>Multitasking is an important step in making a functional OS. There are 2 models that I could employ, cooperative and preemptive multitasking. Cooperative is easier to implement because tasks voluntarily give up time to allow to scheduler to spawn the next task. Benefits of Cooperative multitasking include a smaller resource footprint because tasks can save what it needs before switching, whilst the preemptive model must save everything as the kernel has no way of knowing what the task will need to keep. However a single task can run for a potentially infinite time by not passing control back to the scheduler. Since the cooperative model is easier to implement I implemented it in the holidays. Next week I will create a preemptive scheduler.</p>
<h3 id=how-does-asyncawait-work>How does async/await work?<a hidden class=anchor aria-hidden=true href=#how-does-asyncawait-work>#</a></h3>
<p>The specific intrinsics are dependent on the language, however for Rust there are 3 things that must be created, an Executor, a Waker and Tasks. When each task is Polled it will try and run to completion if it reaches a bottleneck where it must wait, such as reading from a disk, it yielded it&rsquo;s time slice etc, it returns <code>Poll::Pending</code> this tells the executor that is must try again later. Alternatively the process returns <code>Poll:Ready(())</code> , the executor can then remove the task from the task list. But how does the Executor know to try a process again, we could simply add the task to the end of the queue however Rust employs a tactic known as the Waker, when a task must wait it passes a Waker which fundamentally will tell the Executor that the task can do more work. This system works because the waiting will likely be solved by another thread or an interrupt which can then call the Waker and in time the task can continue processing the data.</p>
<h3 id=basic-task>Basic Task<a hidden class=anchor aria-hidden=true href=#basic-task>#</a></h3>
<p>The example shown in the code snippet spawns a task which then waits for an asynchronous number to be resolved and then prints it out to the screen. This demonstrates how async tasks can wait on their own nested tasks making a tree of async tasks.
<img loading=lazy src=async.png alt="Basic task screenshot" title="Basic task screenshot">
</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#e6db74>/// Returns an async number
</span><span style=color:#e6db74>/// Simulates an IO wait by yielding immediatly
</span><span style=color:#e6db74></span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_async_number</span>() -&gt; <span style=color:#66d9ef>u8</span> {
	yield_now().<span style=color:#66d9ef>await</span>;
	<span style=color:#ae81ff>32</span>
}

<span style=color:#e6db74>/// Gets an async number and prints it to the screen
</span><span style=color:#e6db74></span><span style=color:#66d9ef>async</span> print_number() {
	<span style=color:#66d9ef>let</span> number <span style=color:#f92672>=</span> get_async_number().<span style=color:#66d9ef>await</span>;
	println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;The number is: {}&#34;</span>, number);
}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>(boot_info: <span style=color:#66d9ef>&amp;</span>&#39;static BootInfo) -&gt; <span style=color:#f92672>!</span> {
	<span style=color:#75715e>// Initalization code
</span><span style=color:#75715e></span>	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>	
	<span style=color:#75715e>// The executor which will run all our tasks
</span><span style=color:#75715e></span>	println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Initializing EXECUTOR...&#34;</span>);
	<span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> executor <span style=color:#f92672>=</span> Executor::new();
	
	<span style=color:#75715e>// The spawner is a thread safe spawner
</span><span style=color:#75715e></span>	<span style=color:#75715e>// It can be passed to tasks so that tasks can spawn new tasks
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>let</span> spawner <span style=color:#f92672>=</span> executor.get_spawner();

	spawner.spawn(Task::new(print_number()));

	<span style=color:#75715e>// Start the executor
</span><span style=color:#75715e></span>	println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Starting EXECUTOR...&#34;</span>);
	executor.run()

	<span style=color:#75715e>// The kernel main cannot end so infinite loop
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>loop</span> { <span style=color:#66d9ef>unsafe</span> { asm<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;hlt&#34;</span>) } }
}
</code></pre></div><h3 id=async-keyboard>Async Keyboard<a hidden class=anchor aria-hidden=true href=#async-keyboard>#</a></h3>
<p>I also implemented a scan code stream for the keyboard which appended keystrokes to an array and then notifies the Executor that the keyboard task can keep doing work. A benefit of this is that as shown in the below code snippet the Keyboard can be a local variable instead of a Global static. Another benefit is all the keyboard handling code is run outside the interrupt loop, allowing interrupts to be processed as quickly as possible.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_keypresses</span>() {
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> scancodes <span style=color:#f92672>=</span> ScancodeStream::new();
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> keyboard <span style=color:#f92672>=</span> Keyboard::new(Us104Key, ScancodeSet1, HandleControl::Ignore);

    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Starting keyboard handler...&#34;</span>);

    <span style=color:#75715e>// This loop should never return
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(scancode) <span style=color:#f92672>=</span> scancodes.next().<span style=color:#66d9ef>await</span> {
        <span style=color:#75715e>// Process the next scancode
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Ok(Some(key_event)) <span style=color:#f92672>=</span> keyboard.add_byte(scancode) {
            <span style=color:#75715e>// If there is a new key available
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(key) <span style=color:#f92672>=</span> keyboard.process_keyevent(key_event) {
                <span style=color:#75715e>// Print out the key to the screen
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>match</span> key {
                    DecodedKey::Unicode(character) <span style=color:#f92672>=&gt;</span> print<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;{}&#34;</span>, character),
                    DecodedKey::RawKey(key) <span style=color:#f92672>=&gt;</span> print<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;{:?}&#34;</span>, key),
                }
            }
        }
    }
}
</code></pre></div><h2 id=disk-io-via-ata>Disk IO via ATA<a hidden class=anchor aria-hidden=true href=#disk-io-via-ata>#</a></h2>
<h3 id=how-does-ata-work>How does ATA work?<a hidden class=anchor aria-hidden=true href=#how-does-ata-work>#</a></h3>
<p>To read/write to an a disk you must first know which ATA bus it is connected to. There are 4 locations ATA 0 Primary/ Secondary and ATA 1 Primary/ Secondary. Then you can ask the device to read or write bytes to the disk, afterwords you can either poll the disk until it says ready (which is what I implemented) or you can ask it send you an interrupt when it is ready. Once the drive is ready you can read/write <strong>all</strong> 512 bytes from the sector, it is important that all 512 bytes are used otherwise the drive might malfunction.</p>
<h3 id=disk-enumeration>Disk enumeration<a hidden class=anchor aria-hidden=true href=#disk-enumeration>#</a></h3>
<p>To enumerate each disk I identified each of the 4 ATA drives and then printed it&rsquo;s disk name if there was a disk connected as shown in the snippet and screenshot below. The ERROR shown in the screenshot is because there was no disk connected to ATA 1.</p>
<p><img loading=lazy src=ATA.png alt="&amp;ldquo;ATA disk enumeration screenshot&amp;rdquo;" title="ATA disk enumeration screenshot">
</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read_disks</span>() {
	<span style=color:#75715e>// ATA 0 lives on IO port 0x1F0
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> ata_0_master <span style=color:#f92672>=</span> ATA::new(<span style=color:#ae81ff>0x1F0</span>, <span style=color:#66d9ef>true</span>);
	<span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> ata_0_slave  <span style=color:#f92672>=</span> ATA::new(<span style=color:#ae81ff>0x1F0</span>, <span style=color:#66d9ef>false</span>);
	<span style=color:#75715e>// ATA 1 lives on IO port 0x170
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> ata_1_master <span style=color:#f92672>=</span> ATA::new(<span style=color:#ae81ff>0x170</span>, <span style=color:#66d9ef>true</span>);
	<span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> ata_1_slave  <span style=color:#f92672>=</span> ATA::new(<span style=color:#ae81ff>0x170</span>, <span style=color:#66d9ef>true</span>);
	
	<span style=color:#75715e>// Indentify disks
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>let</span> ata_0_master_info <span style=color:#f92672>=</span> ata_0_master.identify(Vec::with_capacity(<span style=color:#ae81ff>512</span>));
	<span style=color:#66d9ef>let</span> ata_0_slave_info <span style=color:#f92672>=</span> ata_0_slave.identify(Vec::with_capacity(<span style=color:#ae81ff>512</span>));
	<span style=color:#66d9ef>let</span> ata_1_master_info <span style=color:#f92672>=</span> ata_1_master.identify(Vec::with_capacity(<span style=color:#ae81ff>512</span>));
	<span style=color:#66d9ef>let</span> ata_1_slave_info <span style=color:#f92672>=</span> ata_1_slave.identify(Vec::with_capacity(<span style=color:#ae81ff>512</span>));

	<span style=color:#75715e>// Print info for each disk
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> (ata_info, name) <span style=color:#66d9ef>in</span> [
		(ata_0_master_info, <span style=color:#e6db74>&#34;ATA 0 Master&#34;</span>),
		(ata_0_slave_info, <span style=color:#e6db74>&#34;ATA 0 Slave&#34;</span>),
		(ata_1_master_info, <span style=color:#e6db74>&#34;ATA 1 Master&#34;</span>),
		(ata_1_slave_info, <span style=color:#e6db74>&#34;ATA 1 Slave&#34;</span>),
	] {
        <span style=color:#75715e>// Was there a disk on this bus
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span>  <span style=color:#66d9ef>let</span>  Some(info) <span style=color:#f92672>=</span>  ata_info {
			println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Found drive on {}&#34;</span>, name);
			println<span style=color:#f92672>!</span>(
				<span style=color:#e6db74>&#34; Serial: {}\n Model: {}&#34;</span>,
				<span style=color:#66d9ef>str</span>::from_utf8(<span style=color:#f92672>&amp;</span>info.serial).unwrap_or(<span style=color:#e6db74>&#34;INVALID SERIAL&#34;</span>),
				<span style=color:#66d9ef>str</span>::from_utf8(<span style=color:#f92672>&amp;</span>info.model).unwrap_or(<span style=color:#e6db74>&#34;INVALID MODEL&#34;</span>),
			);
        } <span style=color:#66d9ef>else</span> {
            println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;No drive found on {}&#34;</span>, name)
        }
	 }
}
</code></pre></div><h3 id=interrupts-challenge>Interrupts Challenge<a hidden class=anchor aria-hidden=true href=#interrupts-challenge>#</a></h3>
<p>Initially this code created a DOUBLE_FAULT exception in QEMU but worked in VirtualBox. This made me think that the drive was sending an interrupt which caused the crash as I wasn&rsquo;t handling it. Eventually I found out that the interrupts were at interrupt number 14 and 15, however I wasn&rsquo;t able to set them. The reason for this was that they were offsets from the PIC chip which meant that they started at offset 0x20. With this change the interrupt handlers worked and in QEMU I got an interrupt and was able to continue execution.</p>
<h2 id=pci-enumeration>PCI Enumeration<a hidden class=anchor aria-hidden=true href=#pci-enumeration>#</a></h2>
<p>To enumerate the PCI devices in quite simple, you use for loops. In this code snippet below, we ask each PCI device to tell us its infomation. If none exists on that address a 0 or 0xFFFF is returned. I used wyoos <a href="https://www.youtube.com/watch?v=GE7iO2vlLD4&list=PLHh55M_Kq4OApWScZyPl5HhgsTJS9MZ6M&index=11">PCI enumeration</a> tutorial as a starting point for this section.</p>
<p>This code snipped shows how I went about enurmerating the PCI devices. The screenshot below also shows that it successfully works.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>select_drivers</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
	<span style=color:#66d9ef>for</span> bus <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..<span style=color:#ae81ff>8</span> {
		<span style=color:#66d9ef>for</span> device <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..<span style=color:#ae81ff>32</span> {
			<span style=color:#66d9ef>for</span> function <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..<span style=color:#ae81ff>8</span> {
				<span style=color:#75715e>// Get device info
</span><span style=color:#75715e></span>				<span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> dev <span style=color:#f92672>=</span> self.get_device_descriptor(bus, device, function);

				<span style=color:#66d9ef>if</span> dev.vendor_id <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x0000</span> <span style=color:#f92672>||</span> dev.vendor_id <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xFFFF</span> {
					<span style=color:#75715e>// There is no function here :(
</span><span style=color:#75715e></span>					<span style=color:#66d9ef>continue</span>;
				}

				<span style=color:#75715e>// Enermuerate over each base address that the device has
</span><span style=color:#75715e></span>				<span style=color:#66d9ef>for</span> bar_num <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..<span style=color:#ae81ff>6</span> {
					<span style=color:#66d9ef>let</span> bar <span style=color:#f92672>=</span>
						<span style=color:#66d9ef>match</span> self.get_base_address_register(bus, device, function, bar_num) {
							Some(bar) <span style=color:#f92672>=&gt;</span> bar,
							None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>continue</span>,
						};

					<span style=color:#75715e>// Ensure there is an address
</span><span style=color:#75715e></span>					<span style=color:#75715e>// We currently only have support for IO not mmap
</span><span style=color:#75715e></span>					<span style=color:#66d9ef>if</span> bar.address <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>
						<span style=color:#f92672>&amp;&amp;</span> (bar.register_type <span style=color:#f92672>==</span> BaseAddressRegisterType::InputOutput)
					{
						dev.port_base <span style=color:#f92672>=</span> bar.address.into()
					}
				}

				println<span style=color:#f92672>!</span>(
					<span style=color:#e6db74>&#34;PCI BUS {}, DEVICE {}, FUNCTION {} = VENDOR {:#X}{:X}, DEVICE {:#X}{:02X}&#34;</span>,
					bus <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFF</span>,
					device <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFF</span>,
					function <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFF</span>,
					(dev.vendor_id <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFF00</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>8</span>,
					dev.vendor_id <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFF</span>,
					(dev.device_id <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFF00</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>8</span>,
					dev.device_id <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFF</span>
				);
			}
		}
	}
}
</code></pre></div><p><img loading=lazy src=PCI.png alt="PCI enumeration" title="PCI enumeration">
</p>
<h2 id=timeline-update>Timeline update<a hidden class=anchor aria-hidden=true href=#timeline-update>#</a></h2>
<p>In the holidays I completed many of the tasks from my <a href=https://craftydh.github.io/CraftyOS-Blog/posts/restart/#revised-timeline>Timeline</a>. However as stated earlier the USB spec is over 600 pages and as such I will be skipping it. As cooperative multiasking has it&rsquo;s weeknesses next week I will work on preemtive multitasking instead of moving onto creating a filesystem.</p>
</div>
<footer class=post-footer>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://craftydh.github.io/CraftyOS-Blog/>CraftyOS Blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>