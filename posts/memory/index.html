<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Memory - Mapping and a Global Allocator | CraftyOS Blog</title>
<meta name=keywords content>
<meta name=description content="Memory Memory is an essential component to a functioning OS, it allows for dynamic content such as strings and other data types which need to be stored on the heap. Therefore mapping will first need to be implemented to be able to read and write to virtual memory locations which are stored at some other physical memory location. After this a Global Allocator which takes a page and builds a heap on it, for these purpose a linked list allocator will be used for allocations over 2 MiB, and a Fixed Size Allocator for smaller allocations allowing for fast allocations.">
<meta name=author content="CraftyDH">
<link rel=canonical href=https://craftydh.github.io/CraftyOS-Blog/posts/memory/>
<link crossorigin=anonymous href=/CraftyOS-Blog/assets/css/stylesheet.min.6cba0d81b5f3f42bb578d49f402ba4175aa72b43def148780b8ad714c957c6f5.css integrity="sha256-bLoNgbXz9Cu1eNSfQCukF1qnK0Pe8Uh4C4rXFMlXxvU=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/CraftyOS-Blog/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://craftydh.github.io/CraftyOS-Blog/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://craftydh.github.io/CraftyOS-Blog/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://craftydh.github.io/CraftyOS-Blog/favicon-32x32.png>
<link rel=apple-touch-icon href=https://craftydh.github.io/CraftyOS-Blog/apple-touch-icon.png>
<link rel=mask-icon href=https://craftydh.github.io/CraftyOS-Blog/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<meta property="og:title" content="Memory - Mapping and a Global Allocator">
<meta property="og:description" content="Memory Memory is an essential component to a functioning OS, it allows for dynamic content such as strings and other data types which need to be stored on the heap. Therefore mapping will first need to be implemented to be able to read and write to virtual memory locations which are stored at some other physical memory location. After this a Global Allocator which takes a page and builds a heap on it, for these purpose a linked list allocator will be used for allocations over 2 MiB, and a Fixed Size Allocator for smaller allocations allowing for fast allocations.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://craftydh.github.io/CraftyOS-Blog/posts/memory/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-09-06T00:00:00+00:00">
<meta property="article:modified_time" content="2021-09-06T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Memory - Mapping and a Global Allocator">
<meta name=twitter:description content="Memory Memory is an essential component to a functioning OS, it allows for dynamic content such as strings and other data types which need to be stored on the heap. Therefore mapping will first need to be implemented to be able to read and write to virtual memory locations which are stored at some other physical memory location. After this a Global Allocator which takes a page and builds a heap on it, for these purpose a linked list allocator will be used for allocations over 2 MiB, and a Fixed Size Allocator for smaller allocations allowing for fast allocations.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://craftydh.github.io/CraftyOS-Blog/posts/"},{"@type":"ListItem","position":2,"name":"Memory - Mapping and a Global Allocator","item":"https://craftydh.github.io/CraftyOS-Blog/posts/memory/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Memory - Mapping and a Global Allocator","name":"Memory - Mapping and a Global Allocator","description":"Memory Memory is an essential component to a functioning OS, it allows for dynamic content such as strings and other data types which need to be stored on the heap. Therefore mapping will first need to be implemented to be able to read and write to virtual memory locations which are stored at some other physical memory location. After this a Global Allocator which takes a page and builds a heap on it, for these purpose a linked list allocator will be used for allocations over 2 MiB, and a Fixed Size Allocator for smaller allocations allowing for fast allocations.","keywords":[],"articleBody":"Memory Memory is an essential component to a functioning OS, it allows for dynamic content such as strings and other data types which need to be stored on the heap. Therefore mapping will first need to be implemented to be able to read and write to virtual memory locations which are stored at some other physical memory location. After this a Global Allocator which takes a page and builds a heap on it, for these purpose a linked list allocator will be used for allocations over 2 MiB, and a Fixed Size Allocator for smaller allocations allowing for fast allocations.\nTimeline In this week the Paging and Global Allocator were quite easy to write due to the help of Phillop’s tutorials help. As I have successfully completed all taskes set out in the project’s timeline, i am currently on track to begin work on Multitasking next week.\nMapping To handle paging I first needed to get the bootloader to pass a MemoryMap that was taken from the BIOS. This MemoryMap shows what is currently stored in every chunk of memory, such as hardware used memory or where the kernel was loaded. With this I wrote a mapper that tells the CPU the new mappings. An example where I wrote a string to 0xDEADBEEF and read it back from 0xBEEF is as follows.\n// Map 0xDEADBEEF to 0xBEEF let virtualAddr = Page::containing_address(VirtAddr::new(0xDEADBEEF)); let physicalAddr = PhysFrame::containing_address(PhysAddr::new(0xBEEF)); // Create the mapping memory::create_mapping(virtualAddr, \u0026mut mapper, physicalAddr, \u0026mut frame_allocator); unsafe { // Write string to the raw pointer \t*(0xDEADBEEF as *mut \u0026str) = \"Storing this string at 0xDEADBEEF...\"; // Read string from the raw pointer \tprintln!(\"The string at 0xBEEF: {}\", *(0xBEEF as *mut \u0026str)); } When I run this is Qemu the expected output is that we can read the same value from the other address, and thats what we see!\nGlobal Allocator For the Global Allocator, I implemented three different implementations. Firstly a bump allocator which provides fast performance, however memory can’t be freed unless everything is freed due to it not tracking which memory it allocates to each process. Secondly a linked list allocator which allows for tracking free space, however due to it having to track the entire list to find a suitable location a third type was implemented. The third type is a fixed size allocator, this is functionally very similar to a linked list allocator except each chunk is a fixed size, this allows fast allocations as the first available block can be popped of the list. A linked list allocator is used behind this the allocate more fixed size blocks if needed and for blocks over 2 KiB as those a rare.\nIn the following example I create a string (which is stored on the heap) and append various strings to it, this shows that the heap works and can grow an allocation.\nlet mut string = String::from(\"This\"); let variable = \" is\"; string += variable; string += \" a\"; string += \" string.\"; println!(\"{}\", string); The expected output should be the string “This is a string.” and as shown in the following image that is what we see!\nChallenges The biggest challenge that I had was to write a memory allocator that was capable of being fast. As this is a kernel slow response times are detremental to the rest of the OS. To combat this the allocator type I choses was the fixed size allocator as it contains lists of available blocks in power of 2 chunks, (8, 16, 32, 64, 128, 256, 512, 1024, 2048) Bytes. For allocations larger than this the fallbock linked list allocator is used.\n","wordCount":"603","inLanguage":"en","datePublished":"2021-09-06T00:00:00Z","dateModified":"2021-09-06T00:00:00Z","author":{"@type":"Person","name":"CraftyDH"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://craftydh.github.io/CraftyOS-Blog/posts/memory/"},"publisher":{"@type":"Organization","name":"CraftyOS Blog","logo":{"@type":"ImageObject","url":"https://craftydh.github.io/CraftyOS-Blog/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://craftydh.github.io/CraftyOS-Blog/ accesskey=h title="CraftyOS Blog (Alt + H)">CraftyOS Blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://craftydh.github.io/CraftyOS-Blog/archives title=Archive>
<span>Archive</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Memory - Mapping and a Global Allocator
</h1>
<div class=post-meta>September 6, 2021&nbsp;·&nbsp;CraftyDH
</div>
</header>
<div class=post-content><h2 id=memory>Memory<a hidden class=anchor aria-hidden=true href=#memory>#</a></h2>
<p>Memory is an essential component to a functioning OS, it allows for dynamic content such as strings and other data types which need to be stored on the heap. Therefore mapping will first need to be implemented to be able to read and write to virtual memory locations which are stored at some other physical memory location. After this a Global Allocator which takes a page and builds a heap on it, for these purpose a linked list allocator will be used for allocations over 2 MiB, and a Fixed Size Allocator for smaller allocations allowing for fast allocations.</p>
<h3 id=timeline>Timeline<a hidden class=anchor aria-hidden=true href=#timeline>#</a></h3>
<p>In this week the Paging and Global Allocator were quite easy to write due to the help of Phillop&rsquo;s tutorials help. As I have successfully completed all taskes set out in the <a href=https://craftydh.github.io/CraftyOS-Blog/posts/restart/#revised-timeline>project&rsquo;s timeline</a>, i am currently on track to begin work on Multitasking next week.</p>
<h2 id=mapping>Mapping<a hidden class=anchor aria-hidden=true href=#mapping>#</a></h2>
<p>To handle paging I first needed to get the bootloader to pass a MemoryMap that was taken from the BIOS. This MemoryMap shows what is currently stored in every chunk of memory, such as hardware used memory or where the kernel was loaded. With this I wrote a mapper that tells the CPU the new mappings. An example where I wrote a string to 0xDEADBEEF and read it back from 0xBEEF is as follows.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// Map 0xDEADBEEF to 0xBEEF
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> virtualAddr <span style=color:#f92672>=</span> Page::containing_address(VirtAddr::new(<span style=color:#ae81ff>0xDEADBEEF</span>));
<span style=color:#66d9ef>let</span> physicalAddr <span style=color:#f92672>=</span> PhysFrame::containing_address(PhysAddr::new(<span style=color:#ae81ff>0xBEEF</span>));
<span style=color:#75715e>// Create the mapping
</span><span style=color:#75715e></span>memory::create_mapping(virtualAddr, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> mapper, physicalAddr, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> frame_allocator);

<span style=color:#66d9ef>unsafe</span> {
	<span style=color:#75715e>// Write string to the raw pointer
</span><span style=color:#75715e></span>	<span style=color:#f92672>*</span>(<span style=color:#ae81ff>0xDEADBEEF</span>  <span style=color:#66d9ef>as</span>  <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span>  <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>str</span>) <span style=color:#f92672>=</span>  <span style=color:#e6db74>&#34;Storing this string at 0xDEADBEEF...&#34;</span>;
	<span style=color:#75715e>// Read string from the raw pointer
</span><span style=color:#75715e></span>	println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;The string at 0xBEEF: {}&#34;</span>, <span style=color:#f92672>*</span>(<span style=color:#ae81ff>0xBEEF</span>  <span style=color:#66d9ef>as</span>  <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span>  <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>str</span>));
}
</code></pre></div><p>When I run this is Qemu the expected output is that we can read the same value from the other address, and thats what we see!</p>
<p><img loading=lazy src=mapping.png alt="Mapping test screenshot" title="Mapping test screenshot">
</p>
<h2 id=global-allocator>Global Allocator<a hidden class=anchor aria-hidden=true href=#global-allocator>#</a></h2>
<p>For the Global Allocator, I implemented three different implementations. Firstly a <a href=https://os.phil-opp.com/allocator-designs/#bump-allocator>bump allocator</a> which provides fast performance, however memory can&rsquo;t be freed unless everything is freed due to it not tracking which memory it allocates to each process. Secondly a <a href=https://os.phil-opp.com/allocator-designs/#bump-allocator>linked list allocator</a> which allows for tracking free space, however due to it having to track the entire list to find a suitable location a third type was implemented. The third type is a <a href=https://os.phil-opp.com/allocator-designs/#fixed-size-block-allocator>fixed size allocator</a>, this is functionally very similar to a linked list allocator except each chunk is a fixed size, this allows fast allocations as the first available block can be popped of the list. A linked list allocator is used behind this the allocate more fixed size blocks if needed and for blocks over 2 KiB as those a rare.</p>
<p>In the following example I create a string (which is stored on the heap) and append various strings to it, this shows that the heap works and can grow an allocation.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> string <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;This&#34;</span>);
<span style=color:#66d9ef>let</span> variable <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34; is&#34;</span>;
string <span style=color:#f92672>+=</span> variable;
string <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34; a&#34;</span>;
string <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34; string.&#34;</span>;

println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;{}&#34;</span>, string);
</code></pre></div><p>The expected output should be the string &ldquo;This is a string.&rdquo; and as shown in the following image that is what we see!</p>
<p><img loading=lazy src=string.png alt="&amp;ldquo;Heap test&amp;rdquo;" title="Heap test">
</p>
<h2 id=challenges>Challenges<a hidden class=anchor aria-hidden=true href=#challenges>#</a></h2>
<p>The biggest challenge that I had was to write a memory allocator that was capable of being fast. As this is a kernel slow response times are detremental to the rest of the OS. To combat this the allocator type I choses was the fixed size allocator as it contains lists of available blocks in power of 2 chunks, (8, 16, 32, 64, 128, 256, 512, 1024, 2048) Bytes. For allocations larger than this the fallbock linked list allocator is used.</p>
</div>
<footer class=post-footer>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://craftydh.github.io/CraftyOS-Blog/>CraftyOS Blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>