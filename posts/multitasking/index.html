<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Multitasking -- Async/Await, Disk IO and PCI Enumeration | CraftyOS Blog</title>
<meta name=keywords content>
<meta name=description content="Multitasking via async/await Multitasking is an important step in making a functional OS. There are 2 models that I could employ, cooperative and preemptive multitasking. Cooperative is easier to implement because tasks voluntarily give up time to allow to scheduler to spawn the next task. Benefits of Cooperative multitasking include a smaller resource footprint because tasks can save what it needs before switching, whilst the preemptive model must save everything as the kernel has no way of knowing what the task will need to keep.">
<meta name=author content="CraftyDH">
<link rel=canonical href=https://craftydh.github.io/CraftyOS-Blog/posts/multitasking/>
<link crossorigin=anonymous href=/CraftyOS-Blog/assets/css/stylesheet.min.6cba0d81b5f3f42bb578d49f402ba4175aa72b43def148780b8ad714c957c6f5.css integrity="sha256-bLoNgbXz9Cu1eNSfQCukF1qnK0Pe8Uh4C4rXFMlXxvU=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/CraftyOS-Blog/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://craftydh.github.io/CraftyOS-Blog/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://craftydh.github.io/CraftyOS-Blog/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://craftydh.github.io/CraftyOS-Blog/favicon-32x32.png>
<link rel=apple-touch-icon href=https://craftydh.github.io/CraftyOS-Blog/apple-touch-icon.png>
<link rel=mask-icon href=https://craftydh.github.io/CraftyOS-Blog/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<meta property="og:title" content="Multitasking -- Async/Await, Disk IO and PCI Enumeration">
<meta property="og:description" content="Multitasking via async/await Multitasking is an important step in making a functional OS. There are 2 models that I could employ, cooperative and preemptive multitasking. Cooperative is easier to implement because tasks voluntarily give up time to allow to scheduler to spawn the next task. Benefits of Cooperative multitasking include a smaller resource footprint because tasks can save what it needs before switching, whilst the preemptive model must save everything as the kernel has no way of knowing what the task will need to keep.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://craftydh.github.io/CraftyOS-Blog/posts/multitasking/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-10-03T00:00:00+00:00">
<meta property="article:modified_time" content="2021-10-03T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Multitasking -- Async/Await, Disk IO and PCI Enumeration">
<meta name=twitter:description content="Multitasking via async/await Multitasking is an important step in making a functional OS. There are 2 models that I could employ, cooperative and preemptive multitasking. Cooperative is easier to implement because tasks voluntarily give up time to allow to scheduler to spawn the next task. Benefits of Cooperative multitasking include a smaller resource footprint because tasks can save what it needs before switching, whilst the preemptive model must save everything as the kernel has no way of knowing what the task will need to keep.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://craftydh.github.io/CraftyOS-Blog/posts/"},{"@type":"ListItem","position":2,"name":"Multitasking -- Async/Await, Disk IO and PCI Enumeration","item":"https://craftydh.github.io/CraftyOS-Blog/posts/multitasking/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Multitasking -- Async/Await, Disk IO and PCI Enumeration","name":"Multitasking -- Async\/Await, Disk IO and PCI Enumeration","description":"Multitasking via async/await Multitasking is an important step in making a functional OS. There are 2 models that I could employ, cooperative and preemptive multitasking. Cooperative is easier to implement because tasks voluntarily give up time to allow to scheduler to spawn the next task. Benefits of Cooperative multitasking include a smaller resource footprint because tasks can save what it needs before switching, whilst the preemptive model must save everything as the kernel has no way of knowing what the task will need to keep.","keywords":[],"articleBody":"Multitasking via async/await Multitasking is an important step in making a functional OS. There are 2 models that I could employ, cooperative and preemptive multitasking. Cooperative is easier to implement because tasks voluntarily give up time to allow to scheduler to spawn the next task. Benefits of Cooperative multitasking include a smaller resource footprint because tasks can save what it needs before switching, whilst the preemptive model must save everything as the kernel has no way of knowing what the task will need to keep. However a single task can run for a potentially infinite time by not passing control back to the scheduler. Since the cooperative model is easier to implement I implemented it in the holidays. Next week I will create a preemptive scheduler.\nHow does async/await work? The specific intrinsics are dependent on the language, however for Rust there are 3 things that must be created, an Executor, a Waker and Tasks. When each task is Polled it will try and run to completion if it reaches a bottleneck where it must wait, such as reading from a disk, it yielded it’s time slice etc, it returns Poll::Pending this tells the executor that is must try again later. Alternatively the process returns Poll:Ready(()) , the executor can then remove the task from the task list. But how does the Executor know to try a process again, we could simply add the task to the end of the queue however Rust employs a tactic known as the Waker, when a task must wait it passes a Waker which fundamentally will tell the Executor that the task can do more work. This system works because the waiting will likely be solved by another thread or an interrupt which can then call the Waker and in time the task can continue processing the data.\nBasic Task The example shown in the code snippet spawns a task which then waits for an asynchronous number to be resolved and then prints it out to the screen. This demonstrates how async tasks can wait on their own nested tasks making a tree of async tasks. /// Returns an async number /// Simulates an IO wait by yielding immediatly async fn get_async_number() - u8 { yield_now().await; 32 } /// Gets an async number and prints it to the screen async print_number() { let number = get_async_number().await; println!(\"The number is: {}\", number); } fn main(boot_info: \u0026'static BootInfo) - ! { // Initalization code \t// ... \t// The executor which will run all our tasks \tprintln!(\"Initializing EXECUTOR...\"); let mut executor = Executor::new(); // The spawner is a thread safe spawner \t// It can be passed to tasks so that tasks can spawn new tasks \tlet spawner = executor.get_spawner(); spawner.spawn(Task::new(print_number())); // Start the executor \tprintln!(\"Starting EXECUTOR...\"); executor.run() // The kernel main cannot end so infinite loop \tloop { unsafe { asm!(\"hlt\") } } } Async Keyboard I also implemented a scan code stream for the keyboard which appended keystrokes to an array and then notifies the Executor that the keyboard task can keep doing work. A benefit of this is that as shown in the below code snippet the Keyboard can be a local variable instead of a Global static. Another benefit is all the keyboard handling code is run outside the interrupt loop, allowing interrupts to be processed as quickly as possible.\npub async fn print_keypresses() { let mut scancodes = ScancodeStream::new(); let mut keyboard = Keyboard::new(Us104Key, ScancodeSet1, HandleControl::Ignore); println!(\"Starting keyboard handler...\"); // This loop should never return  while let Some(scancode) = scancodes.next().await { if let Ok(Some(key_event)) = keyboard.add_byte(scancode) { if let Some(key) = keyboard.process_keyevent(key_event) { match key { DecodedKey::Unicode(character) = print!(\"{}\", character), DecodedKey::RawKey(key) = print!(\"{:?}\", key), } } } } } Disk IO via ATA Todo! PCI Enumeration Todo! ","wordCount":"624","inLanguage":"en","datePublished":"2021-10-03T00:00:00Z","dateModified":"2021-10-03T00:00:00Z","author":{"@type":"Person","name":"CraftyDH"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://craftydh.github.io/CraftyOS-Blog/posts/multitasking/"},"publisher":{"@type":"Organization","name":"CraftyOS Blog","logo":{"@type":"ImageObject","url":"https://craftydh.github.io/CraftyOS-Blog/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://craftydh.github.io/CraftyOS-Blog/ accesskey=h title="CraftyOS Blog (Alt + H)">CraftyOS Blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://craftydh.github.io/CraftyOS-Blog/archives title=Archive>
<span>Archive</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Multitasking -- Async/Await, Disk IO and PCI Enumeration
</h1>
<div class=post-meta>October 3, 2021&nbsp;·&nbsp;CraftyDH
</div>
</header>
<div class=post-content><h2 id=multitasking-via-asyncawait>Multitasking via async/await<a hidden class=anchor aria-hidden=true href=#multitasking-via-asyncawait>#</a></h2>
<p>Multitasking is an important step in making a functional OS. There are 2 models that I could employ, cooperative and preemptive multitasking. Cooperative is easier to implement because tasks voluntarily give up time to allow to scheduler to spawn the next task. Benefits of Cooperative multitasking include a smaller resource footprint because tasks can save what it needs before switching, whilst the preemptive model must save everything as the kernel has no way of knowing what the task will need to keep. However a single task can run for a potentially infinite time by not passing control back to the scheduler. Since the cooperative model is easier to implement I implemented it in the holidays. Next week I will create a preemptive scheduler.</p>
<h3 id=how-does-asyncawait-work>How does async/await work?<a hidden class=anchor aria-hidden=true href=#how-does-asyncawait-work>#</a></h3>
<p>The specific intrinsics are dependent on the language, however for Rust there are 3 things that must be created, an Executor, a Waker and Tasks. When each task is Polled it will try and run to completion if it reaches a bottleneck where it must wait, such as reading from a disk, it yielded it&rsquo;s time slice etc, it returns <code>Poll::Pending</code> this tells the executor that is must try again later. Alternatively the process returns <code>Poll:Ready(())</code> , the executor can then remove the task from the task list. But how does the Executor know to try a process again, we could simply add the task to the end of the queue however Rust employs a tactic known as the Waker, when a task must wait it passes a Waker which fundamentally will tell the Executor that the task can do more work. This system works because the waiting will likely be solved by another thread or an interrupt which can then call the Waker and in time the task can continue processing the data.</p>
<h3 id=basic-task>Basic Task<a hidden class=anchor aria-hidden=true href=#basic-task>#</a></h3>
<p>The example shown in the code snippet spawns a task which then waits for an asynchronous number to be resolved and then prints it out to the screen. This demonstrates how async tasks can wait on their own nested tasks making a tree of async tasks.
<img loading=lazy src=async.png alt="Basic task screenshot" title="Basic task screenshot">
</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#e6db74>/// Returns an async number
</span><span style=color:#e6db74>/// Simulates an IO wait by yielding immediatly
</span><span style=color:#e6db74></span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_async_number</span>() -&gt; <span style=color:#66d9ef>u8</span> {
	yield_now().<span style=color:#66d9ef>await</span>;
	<span style=color:#ae81ff>32</span>
}

<span style=color:#e6db74>/// Gets an async number and prints it to the screen
</span><span style=color:#e6db74></span><span style=color:#66d9ef>async</span> print_number() {
	<span style=color:#66d9ef>let</span> number <span style=color:#f92672>=</span> get_async_number().<span style=color:#66d9ef>await</span>;
	println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;The number is: {}&#34;</span>, number);
}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>(boot_info: <span style=color:#66d9ef>&amp;</span>&#39;static BootInfo) -&gt; <span style=color:#f92672>!</span> {
	<span style=color:#75715e>// Initalization code
</span><span style=color:#75715e></span>	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>	
	<span style=color:#75715e>// The executor which will run all our tasks
</span><span style=color:#75715e></span>	println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Initializing EXECUTOR...&#34;</span>);
	<span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> executor <span style=color:#f92672>=</span> Executor::new();
	
	<span style=color:#75715e>// The spawner is a thread safe spawner
</span><span style=color:#75715e></span>	<span style=color:#75715e>// It can be passed to tasks so that tasks can spawn new tasks
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>let</span> spawner <span style=color:#f92672>=</span> executor.get_spawner();

	spawner.spawn(Task::new(print_number()));

	<span style=color:#75715e>// Start the executor
</span><span style=color:#75715e></span>	println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Starting EXECUTOR...&#34;</span>);
	executor.run()

	<span style=color:#75715e>// The kernel main cannot end so infinite loop
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>loop</span> { <span style=color:#66d9ef>unsafe</span> { asm<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;hlt&#34;</span>) } }
}
</code></pre></div><h3 id=async-keyboard>Async Keyboard<a hidden class=anchor aria-hidden=true href=#async-keyboard>#</a></h3>
<p>I also implemented a scan code stream for the keyboard which appended keystrokes to an array and then notifies the Executor that the keyboard task can keep doing work. A benefit of this is that as shown in the below code snippet the Keyboard can be a local variable instead of a Global static. Another benefit is all the keyboard handling code is run outside the interrupt loop, allowing interrupts to be processed as quickly as possible.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_keypresses</span>() {
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> scancodes <span style=color:#f92672>=</span> ScancodeStream::new();
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> keyboard <span style=color:#f92672>=</span> Keyboard::new(Us104Key, ScancodeSet1, HandleControl::Ignore);

    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Starting keyboard handler...&#34;</span>);

    <span style=color:#75715e>// This loop should never return
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(scancode) <span style=color:#f92672>=</span> scancodes.next().<span style=color:#66d9ef>await</span> {
        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Ok(Some(key_event)) <span style=color:#f92672>=</span> keyboard.add_byte(scancode) {
            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(key) <span style=color:#f92672>=</span> keyboard.process_keyevent(key_event) {
                <span style=color:#66d9ef>match</span> key {
                    DecodedKey::Unicode(character) <span style=color:#f92672>=&gt;</span> print<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;{}&#34;</span>, character),
                    DecodedKey::RawKey(key) <span style=color:#f92672>=&gt;</span> print<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;{:?}&#34;</span>, key),
                }
            }
        }
    }
}
</code></pre></div><h2 id=disk-io-via-ata>Disk IO via ATA<a hidden class=anchor aria-hidden=true href=#disk-io-via-ata>#</a></h2>
<h3 id=todo>Todo!<a hidden class=anchor aria-hidden=true href=#todo>#</a></h3>
<h2 id=pci-enumeration>PCI Enumeration<a hidden class=anchor aria-hidden=true href=#pci-enumeration>#</a></h2>
<h3 id=todo-1>Todo!<a hidden class=anchor aria-hidden=true href=#todo-1>#</a></h3>
</div>
<footer class=post-footer>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://craftydh.github.io/CraftyOS-Blog/>CraftyOS Blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>