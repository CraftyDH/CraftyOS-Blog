<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Syscalls! | CraftyOS Blog</title>
<meta name=keywords content>
<meta name=description content="What are syscalls Syscalls are a process in a lower privilege level to communicate with higher privilege level code such as the kernel. There are many models for implementing such syscalls, the way I have gone for at the moment is regisiter based.
To call a syscall you must know the syscall number, and then pass the arguments to the next registers. Unfortunately this means I cannot use rust contructs such as Vec&rsquo;s as only C safe values can be directly passed.">
<meta name=author content="CraftyDH">
<link rel=canonical href=https://craftydh.github.io/CraftyOS-Blog/posts/syscalls/>
<link crossorigin=anonymous href=/CraftyOS-Blog/assets/css/stylesheet.min.6cba0d81b5f3f42bb578d49f402ba4175aa72b43def148780b8ad714c957c6f5.css integrity="sha256-bLoNgbXz9Cu1eNSfQCukF1qnK0Pe8Uh4C4rXFMlXxvU=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/CraftyOS-Blog/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://craftydh.github.io/CraftyOS-Blog/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://craftydh.github.io/CraftyOS-Blog/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://craftydh.github.io/CraftyOS-Blog/favicon-32x32.png>
<link rel=apple-touch-icon href=https://craftydh.github.io/CraftyOS-Blog/apple-touch-icon.png>
<link rel=mask-icon href=https://craftydh.github.io/CraftyOS-Blog/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<meta property="og:title" content="Syscalls!">
<meta property="og:description" content="What are syscalls Syscalls are a process in a lower privilege level to communicate with higher privilege level code such as the kernel. There are many models for implementing such syscalls, the way I have gone for at the moment is regisiter based.
To call a syscall you must know the syscall number, and then pass the arguments to the next registers. Unfortunately this means I cannot use rust contructs such as Vec&rsquo;s as only C safe values can be directly passed.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://craftydh.github.io/CraftyOS-Blog/posts/syscalls/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-10-17T00:00:00+00:00">
<meta property="article:modified_time" content="2021-10-17T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Syscalls!">
<meta name=twitter:description content="What are syscalls Syscalls are a process in a lower privilege level to communicate with higher privilege level code such as the kernel. There are many models for implementing such syscalls, the way I have gone for at the moment is regisiter based.
To call a syscall you must know the syscall number, and then pass the arguments to the next registers. Unfortunately this means I cannot use rust contructs such as Vec&rsquo;s as only C safe values can be directly passed.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://craftydh.github.io/CraftyOS-Blog/posts/"},{"@type":"ListItem","position":2,"name":"Syscalls!","item":"https://craftydh.github.io/CraftyOS-Blog/posts/syscalls/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Syscalls!","name":"Syscalls!","description":"What are syscalls Syscalls are a process in a lower privilege level to communicate with higher privilege level code such as the kernel. There are many models for implementing such syscalls, the way I have gone for at the moment is regisiter based.\nTo call a syscall you must know the syscall number, and then pass the arguments to the next registers. Unfortunately this means I cannot use rust contructs such as Vec\u0026rsquo;s as only C safe values can be directly passed.","keywords":[],"articleBody":"What are syscalls Syscalls are a process in a lower privilege level to communicate with higher privilege level code such as the kernel. There are many models for implementing such syscalls, the way I have gone for at the moment is regisiter based.\nTo call a syscall you must know the syscall number, and then pass the arguments to the next registers. Unfortunately this means I cannot use rust contructs such as Vec’s as only C safe values can be directly passed.\nExample ECHO In this syscall test we call the echo command which passes back the same number we send to it.\nTo call it we pass 0 into the command register RAX, and 0xDEADBEEF into the arg1 register r8.\nThe syscall will then return the number in r8 in the return register RAX.\nTo demonstate this the code we will run is.\nunsafe { let mut rax = 0; let test_num = 0xDEADBEEF; asm!(\"int 0x80\", inout(\"rax\") rax, in(r8) test_num); println!(\"The number was: {:#X}\", rax); } As expected we get to number 0xDEADBEEF printed to the console as shown below.\nSpawn Thread This is a very usefull syscall that programs can call. It allows a process to spawn any C function as a new thread, in the thread pool. As I wanted to have closures that can capture surrounting variables to work I needed additional context other than a function pointer. To achieve this I looked into the rust source code for how they handle POSIX threads.\nconst SPAWN_THREAD: usize = 2; pub fn spawn_threadF(func: F) - TaskID where F: FnOnce() + Send + Sync, { let boxed_func: Boxdyn FnOnce() = Box::new(func); let raw = Box::into_raw(Box::new(boxed_func)) as *mut usize; let res = unsafe { syscall1(SPAWN_THREAD, raw as usize) }; TaskID::from(res) } In this function the passed in function is boxed onto the heap and then converted into a raw C pointer.\nHowever, this lead to a problem. I had to call the function from rust after I reconstructed it. However, I cannot call the function within the syscall handler otherwise the Mutex will never be freed.\nThe solution to this was remarkably simple create a bootstrap function. The beauty in this is that I set up the CPU to start running a C function, which then is no longer constrained. Additionally when privilege levels exist the boostraper will not run under ring 0, but whichever ring level the process has.\nextern \"C\" fn thread_bootstraper(main: *mut usize) { // Recreate the function box that was passed from the syscall  let func = unsafe { Box::from_raw(main as *mut Boxdyn FnOnce()) }; // Call the function  func.call_once(()); // Function ended quit  quit_function() } In this function the boxed function is passed in RAX as per the C calling convention. It is then reconstructed and then called from Rust code. The was also a problem which occured when code exited the function and caused a page fault by running non-existed code as shown below. I solved this by adding a quit_function call at the end of the bootstraper.\nYield Now This is a simple syscall that allows a thread to voluntarily give up its time slice. This improves system performance instead of threads wasting time waiting for an event to occur. Additionally I created helper functions for all syscalls that can be called instead of manually calling the interrupt.\nChallenges As mentioned earlier the page fault on a task exiting code segment was quite annoying. By employing a syscall instead of a function it is possible to gain access to the stack frame and straight away switch to the next available task.\nTimeline As I have other classwork to do next week this will be the final entry. The means that I unfortunatly won’t have time to implement networking or a filesystem. However by inserting syscalls into the timeline has been benifitial as it allows for greater asynconous capabilities as demonstated above.\n","wordCount":"649","inLanguage":"en","datePublished":"2021-10-17T00:00:00Z","dateModified":"2021-10-17T00:00:00Z","author":{"@type":"Person","name":"CraftyDH"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://craftydh.github.io/CraftyOS-Blog/posts/syscalls/"},"publisher":{"@type":"Organization","name":"CraftyOS Blog","logo":{"@type":"ImageObject","url":"https://craftydh.github.io/CraftyOS-Blog/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://craftydh.github.io/CraftyOS-Blog/ accesskey=h title="CraftyOS Blog (Alt + H)">CraftyOS Blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://craftydh.github.io/CraftyOS-Blog/archives title=Archive>
<span>Archive</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Syscalls!
</h1>
<div class=post-meta>October 17, 2021&nbsp;·&nbsp;CraftyDH
</div>
</header>
<div class=post-content><h2 id=what-are-syscalls>What are syscalls<a hidden class=anchor aria-hidden=true href=#what-are-syscalls>#</a></h2>
<p>Syscalls are a process in a lower privilege level to communicate with higher privilege level code such as the kernel. There are many models for implementing such syscalls, the way I have gone for at the moment is regisiter based.</p>
<p>To call a syscall you must know the syscall number, and then pass the arguments to the next registers. Unfortunately this means I cannot use rust contructs such as Vec&rsquo;s as only C safe values can be directly passed.</p>
<h2 id=example-echo>Example ECHO<a hidden class=anchor aria-hidden=true href=#example-echo>#</a></h2>
<p>In this syscall test we call the echo command which passes back the same number we send to it.</p>
<p>To call it we pass 0 into the command register RAX, and 0xDEADBEEF into the arg1 register r8.</p>
<p>The syscall will then return the number in r8 in the return register RAX.</p>
<p>To demonstate this the code we will run is.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>unsafe</span> {
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> rax <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>let</span> test_num <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xDEADBEEF</span>;
    asm<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;int 0x80&#34;</span>, inout(<span style=color:#e6db74>&#34;rax&#34;</span>) rax, <span style=color:#66d9ef>in</span>(r8) test_num);
    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;The number was: {:#X}&#34;</span>, rax);
}
</code></pre></div><p>As expected we get to number 0xDEADBEEF printed to the console as shown below.</p>
<p><img loading=lazy src=echo.png alt="&amp;ldquo;Echo screenshot&amp;rdquo;" title="Echo screenshot">
</p>
<h2 id=spawn-thread>Spawn Thread<a hidden class=anchor aria-hidden=true href=#spawn-thread>#</a></h2>
<p>This is a very usefull syscall that programs can call. It allows a process to spawn any C function as a new thread, in the thread pool. As I wanted to have closures that can capture surrounting variables to work I needed additional context other than a function pointer. To achieve this I looked into the rust source code for how they handle POSIX threads.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>const</span> SPAWN_THREAD: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>spawn_thread</span><span style=color:#f92672>&lt;</span>F<span style=color:#f92672>&gt;</span>(func: <span style=color:#a6e22e>F</span>) -&gt; <span style=color:#a6e22e>TaskID</span>
<span style=color:#66d9ef>where</span>
    F: FnOnce() <span style=color:#f92672>+</span> Send <span style=color:#f92672>+</span> Sync,
{
    <span style=color:#66d9ef>let</span> boxed_func: Box<span style=color:#f92672>&lt;</span>dyn FnOnce()<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Box::new(func);
    <span style=color:#66d9ef>let</span> raw <span style=color:#f92672>=</span> Box::into_raw(Box::new(boxed_func)) <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>usize</span>;
    <span style=color:#66d9ef>let</span> res <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { syscall1(SPAWN_THREAD, raw <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>) };
    TaskID::from(res)
}
</code></pre></div><p>In this function the passed in function is boxed onto the heap and then converted into a raw C pointer.</p>
<p>However, this lead to a problem. I had to call the function from rust after I reconstructed it. However, I cannot call the function within the syscall handler otherwise the Mutex will never be freed.</p>
<p>The solution to this was remarkably simple create a bootstrap function. The beauty in this is that I set up the CPU to start running a C function, which then is no longer constrained. Additionally when privilege levels exist the boostraper will not run under ring 0, but whichever ring level the process has.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>thread_bootstraper</span>(main: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>usize</span>) {
    <span style=color:#75715e>// Recreate the function box that was passed from the syscall
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> func <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { Box::from_raw(main <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> Box<span style=color:#f92672>&lt;</span>dyn FnOnce()<span style=color:#f92672>&gt;</span>) };

    <span style=color:#75715e>// Call the function
</span><span style=color:#75715e></span>    func.call_once(());

    <span style=color:#75715e>// Function ended quit
</span><span style=color:#75715e></span>    quit_function()
}
</code></pre></div><p>In this function the boxed function is passed in RAX as per the C calling convention. It is then reconstructed and then called from Rust code. The was also a problem which occured when code exited the function and caused a page fault by running non-existed code as shown below. I solved this by adding a quit_function call at the end of the bootstraper.</p>
<p><img loading=lazy src=pagefault_noquit.png alt="&amp;ldquo;page fault&amp;rdquo;" title="page fault">
</p>
<h2 id=yield-now>Yield Now<a hidden class=anchor aria-hidden=true href=#yield-now>#</a></h2>
<p>This is a simple syscall that allows a thread to voluntarily give up its time slice. This improves system performance instead of threads wasting time waiting for an event to occur. Additionally I created helper functions for all syscalls that can be called instead of manually calling the interrupt.</p>
<h2 id=challenges>Challenges<a hidden class=anchor aria-hidden=true href=#challenges>#</a></h2>
<p>As mentioned earlier the page fault on a task exiting code segment was quite annoying. By employing a syscall instead of a function it is possible to gain access to the stack frame and straight away switch to the next available task.</p>
<h2 id=timeline>Timeline<a hidden class=anchor aria-hidden=true href=#timeline>#</a></h2>
<p>As I have other classwork to do next week this will be the final entry. The means that I unfortunatly won&rsquo;t have time to implement networking or a filesystem. However by inserting syscalls into the timeline has been benifitial as it allows for greater asynconous capabilities as demonstated above.</p>
</div>
<footer class=post-footer>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://craftydh.github.io/CraftyOS-Blog/>CraftyOS Blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>